// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                    String          @id @default(cuid())
  email                 String          @unique
  passwordHash          String
  name                  String
  avatarUrl             String?
  reputation            Int             @default(0)
  credits               String          @default("10.00")
  isVerified            Boolean         @default(false)
  emailVerificationToken String?
  emailVerifiedAt       DateTime?
  lastActiveAt          DateTime?
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt

  profile           Profile?
  provided          Booking[]       @relation("ProvidedBookings")
  received          Booking[]       @relation("ReceivedBookings")
  ledger            LedgerEntry[]
  messages          Message[]       @relation("UserMessages")
  followers         Connection[]    @relation("FolloweeConnections")
  following         Connection[]    @relation("FollowerConnections")
  notifications     Notification[]
  disputes          Dispute[]
  ratings           Rating[]        @relation("RatedUser")
  givenRatings      Rating[]        @relation("RatingUser")
  sentTransactions     Transaction[] @relation("SentTransactions")
 receivedTransactions Transaction[] @relation("ReceivedTransactions")
   sentRequests      TimeRequest[]   @relation("RequestSender")
  receivedRequests  TimeRequest[]   @relation("RequestReceiver")
}

model Profile {
  id           String   @id @default(cuid())
  userId       String   @unique
  displayName  String
  avatarUrl    String?
  bio          String?
  skills       String   @default("[]")
  categories   String   @default("[]")
  availability Json
  location     String?
  ratingAvg    Float?
  totalRatings Int      @default(0)
  introMedia   String?
  isComplete   Boolean  @default(false)
  timezone     String?
  languages    String   @default("[]")
  hourlyRate   String?

  user         User     @relation(fields: [userId], references: [id])
}

enum BookingStatus {
  PENDING
  ACCEPTED
  DECLINED
  CANCELLED
  COMPLETED
}

model Booking {
  id            String        @id @default(cuid())
  providerId    String
  receiverId    String
  hours         String
  category      String
  note          String?
  startAt       DateTime?
  endAt         DateTime?
  status        BookingStatus @default(PENDING)
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  acceptedAt    DateTime?
  completedAt   DateTime?
  cancelledAt   DateTime?

  provider      User          @relation("ProvidedBookings", fields: [providerId], references: [id])
  receiver      User          @relation("ReceivedBookings", fields: [receiverId], references: [id])
  thread        MessageThread?
  ledgerEntries LedgerEntry[]
  dispute       Dispute?

  @@index([providerId])
  @@index([receiverId])
  @@index([status])
}

model MessageThread {
  id        String    @id @default(cuid())
  bookingId String    @unique
  createdAt DateTime  @default(now())

  booking   Booking   @relation(fields: [bookingId], references: [id])
  messages  Message[]
}

model Message {
  id          String    @id @default(cuid())
  threadId    String?
  senderId    String
  receiverId  String?
  content     String
  messageType String    @default("TEXT")
  requestId   String?
  createdAt   DateTime  @default(now())
  readAt      DateTime?

  thread      MessageThread? @relation(fields: [threadId], references: [id])
  sender      User          @relation("UserMessages", fields: [senderId], references: [id])
  request     TimeRequest?  @relation("TimeRequestMessages", fields: [requestId], references: [id])

  @@index([threadId])
  @@index([senderId])
  @@index([requestId])
}

enum LedgerType {
  EARNED
  SPENT
}

model LedgerEntry {
  id           String     @id @default(cuid())
  userId       String
  hours        String
  type         LedgerType
  description  String?
  refBookingId String?
  createdAt    DateTime   @default(now())

  user         User       @relation(fields: [userId], references: [id])
  booking      Booking?   @relation(fields: [refBookingId], references: [id])

  @@index([userId])
  @@index([refBookingId])
  @@index([type])
}

model Connection {
  id          String   @id @default(cuid())
  followerId  String
  followeeId  String
  createdAt   DateTime @default(now())

  follower    User     @relation("FollowerConnections", fields: [followerId], references: [id])
  followee    User     @relation("FolloweeConnections", fields: [followeeId], references: [id])

  @@unique([followerId, followeeId])
  @@index([followerId])
  @@index([followeeId])
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  kind      String
  payload   Json
  readAt    DateTime?
  createdAt DateTime  @default(now())

  user      User      @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([readAt])
}

model Dispute {
  id          String    @id @default(cuid())
  bookingId   String    @unique
  raisedById  String
  reason      String
  status      String    @default("OPEN")
  resolution  String?
  penalty     Int       @default(0)
  createdAt   DateTime  @default(now())
  resolvedAt  DateTime?

  booking     Booking   @relation(fields: [bookingId], references: [id])
  raisedBy    User      @relation(fields: [raisedById], references: [id])

  @@index([raisedById])
}

enum TimeRequestStatus {
  PENDING
  ACCEPTED
  REJECTED
  COMPLETED
  CANCELLED
}

model TimeRequest {
  id           String            @id @default(cuid())
  senderId     String
  receiverId   String
  title        String
  description  String
  duration     String
  proposedDate DateTime?
  status       TimeRequestStatus @default(PENDING)
  credits      String
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  acceptedAt   DateTime?
  completedAt  DateTime?

  sender       User              @relation("RequestSender", fields: [senderId], references: [id])
  receiver     User              @relation("RequestReceiver", fields: [receiverId], references: [id])
  messages     Message[]         @relation("TimeRequestMessages")

  @@index([senderId])
  @@index([receiverId])
  @@index([status])
}

model Rating {
  id        String   @id @default(cuid())
  raterId   String
  ratedId   String
  bookingId String?
  score     Int
  comment   String?
  createdAt DateTime @default(now())

  rater     User     @relation("RatingUser", fields: [raterId], references: [id])
  rated     User     @relation("RatedUser", fields: [ratedId], references: [id])

  @@unique([raterId, ratedId, bookingId])
  @@index([ratedId])
}

enum TransactionType {
  EARNED
  SPENT
  TRANSFER
  REFUND
  BONUS
}

enum TransactionStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
}

model Transaction {
  id          String            @id @default(cuid())
  senderId    String
  receiverId  String?
  amount      String
  type        TransactionType
  status      TransactionStatus @default(PENDING)
  description String?
  referenceId String?           // bookingId or requestId
  createdAt   DateTime          @default(now())
  completedAt DateTime?

  // ðŸ‘‡ FIXED: Added unique relation names
  sender      User              @relation("SentTransactions", fields: [senderId], references: [id])
  receiver    User?             @relation("ReceivedTransactions", fields: [receiverId], references: [id])

  @@index([senderId])
  @@index([receiverId])
  @@index([type])
  @@index([status])
}
